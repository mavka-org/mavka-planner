class Question:
def init(self, soup, args):
self.soup = self.preprocess(soup)
self.args = args
self.order_id = None # can be set via set_order_id()
self.zno_osvita_id = self.get_zno_osvita_id(soup)
self.is_image_question = self.get_is_image_question()

def get_strapi_id(self, strapi_questions):
return None # ToDo

def get_primary_question(self):
primary = self.soup.select_one('div.question')
if primary:
return str(primary)
return None

def get_is_image_question(self):
div = self.soup.select_one('div.question')
if div.img:
if div.text == '':
return True
return False

def get_explanation(self):
explanation = self.soup.select_one('div.explanation')
if explanation:
return str(explanation)
return None

def get_test_strapi_id(self):
return self.args['test_strapi_id'] if 'test_strapi_id' in self.args else None

def get_subject_strapi_id(self):
return self.args['subject_strapi_id']

def get_type_name(self):
return self.class.name

def get_type_strapi_id(self, question_types_strapi_ids):
return question_types_strapi_ids[self.get_type_name()]

def get_topic_name(self, zno_osvita_topics_questions_ids):
if self.zno_osvita_id:
if self.zno_osvita_id in zno_osvita_topics_questions_ids:
return zno_osvita_topics_questions_ids[self.zno_osvita_id]
return None

def get_correct_answer(self):
comm = self.soup.findAll(text=lambda text:isinstance(text, Comment))[-1]
return comm.replace(' => </span> ', '').replace(' <span>', '')

def get_tasks(self):
return None  # overwritten in subclasses

def get_options(self):
return None  # overwritten in subclasses

def get_order_id(self):
return self.order_id

def set_order_id(self, value):
self.order_id = value
return self.order_id

def to_json(self):
return {'soup': str(self.soup), 'args': self.args}

def to_strapi(self, question_types_strapi_ids, zno_osvita_topics_questions_ids):
# this is missing the required order_n field for strapi
    tasks = self.get_tasks()
options = self.get_options()
json = {
# explanation - don't have yet
'test': self.get_test_strapi_id(),
# topic_id - to be determined manually later
'primary_question': self.get_primary_question(),
    'tasks': [{'text': x} for x in tasks] if tasks else None,
    'options': [{'text': x} for x in options] if options else None,
    'correct_answer': self.get_correct_answer(),
    'zno_osvita_is_image_question': self.is_image_question,
    'zno_osvita_explanation': self.get_explanation(),
    'zno_osvita_topic_name': self.get_topic_name(zno_osvita_topics_questions_ids),
    'question_type': self.get_type_strapi_id(question_types_strapi_ids),
    'order_id': self.get_order_id(),
    'zno_osvita_id': self.zno_osvita_id,
    'subject': self.get_subject_strapi_id()
}

for key in list(json.keys()):
if json[key] == None:
del json[key]

return json

@staticmethod
def get_zno_osvita_id(soup):
explanation = soup.select_one('div.explanation')
if explanation:
return str(explanation.get('id').replace('commentar_', ''))
return None

@staticmethod
def preprocess(soup):
# finds and completes src of every image in the soup
imgs = soup.select('img')
for img in imgs:
img['src'] = 'https://zno.osvita.ua' + img['src']
return soup


@staticmethod
def soup_to_quill(soup):
return None  # ToDo


class MultipleChoice(Question):

def get_options(self):
if self.is_image_question:
return [''] * self.n_options
options = copy.copy(self.soup.select_one('div.answers')).select('div.answer')  # copy for decomposition
    for o in options:
o.span.decompose()
return [str(x) for x in options]


class ABCD(MultipleChoice):
def init(self, soup, args):
super().init(soup, args)
self.n_options = 4

class ABCDE(MultipleChoice):
def init(self, soup, args):
super().init(soup, args)
self.n_options = 5

# languages
class TF(MultipleChoice):
def init(self, soup, args):
super().init(soup, args)
self.n_options = 2

class LangMultipleChoice(MultipleChoice):
def init(self, soup, args):
super().init(soup, args)
self.n_options = 0

# old math?
    class OneOutOfSeven(MultipleChoice):
    def init(self, soup, args):
super().init(soup, args)
self.n_options = 7


class Matching(Question):

def get_tasks(self):
if self.is_image_question:
return [''] * self.n_tasks
tasks = copy.copy(self.soup.select('div.answers')[0]).select('div.answer')  # copy for decomposition
    for t in tasks:
t.span.decompose()
return [str(x) for x in tasks]

def get_options(self):
if self.is_image_question:
return [''] * self.n_options
options = copy.copy(self.soup.select('div.answers')[1]).select('div.answer')  # copy for decomposition
    for o in options:
o.span.decompose()
return [str(x) for x in options]


class Matching3x4(Matching):
def init(self, soup, args):
super().init(soup, args)
self.n_tasks = 3
self.n_options = 4

class Matching3x5(Matching):
def init(self, soup, args):
super().init(soup, args)
self.n_tasks = 3
self.n_options = 5

class Matching4x4(Matching):
def init(self, soup, args):
super().init(soup, args)
self.n_tasks = 4
self.n_options = 4

class Matching4x5(Matching):
def init(self, soup, args):
super().init(soup, args)
self.n_tasks = 4
self.n_options = 5

class Matching5x5(Matching):
def init(self, soup, args):
super().init(soup, args)
self.n_tasks = 4
self.n_options = 5


class Open(Question):
pass

class SingleOpen(Open):
pass

class DoubleOpen(Open):
pass


class Free(Question):
pass


# non-math

class Sequencing(Question):
pass

# history
class Sequencing4x4(Sequencing):
pass


class ThreeOutOfSeven(Question):
pass

# bio
class TripleMultipleChoice(Question):
pass